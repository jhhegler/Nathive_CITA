#!/usr/bin/env python
#coding=utf-8

# Nathive (and this file) is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or newer.
#
# You should have received a copy of the GNU General Public License along with
# this file. If not, see <http://www.gnu.org/licenses/>.


import os
import re

from dotcy.function import Function


class Script(object):

    def __init__(self, path):

        self.code = open(path).read()
        head, tail = os.path.split(path)
        self.name, ext = os.path.splitext(tail)
        self.clean()
        self.functions = None
        self.parse_functions()
        self.embed_imports()


    def parse_functions(self):

        functions = self.code.split('def ')
        functions.pop(0)
        functions = [Function(x) for x in functions]
        self.functions = functions


    def get_imports(self):

        calls = re.findall('from .+ import .+', self.code)
        imports = [self.parse_import_call(x) for x in calls]
        return imports


    def parse_import_call(self, call):

        rel, funcname = re.search('from (.+) import (.+)', call).groups()
        rel, funcname = rel.strip(), funcname.strip()
        return rel, funcname


    def embed_imports(self):

        imports = self.get_imports()
        for rel, funcname in reversed(imports):
            path = rel.replace('.', '/')
            path += '.cy'
            script = Script(path)
            function = [x for x in script.functions if x.name == funcname][0]
            if function not in self.functions:
                self.functions.insert(0, function)


    def clean(self):

        # Clean comments.
        self.code = re.sub('#.*\n', '\n', self.code)

        # Clean docstrings.
        regex = re.compile('""".*?"""', re.DOTALL)
        self.code = re.sub(regex, '', self.code)

        # Trim tabs.
        self.code = re.sub('[\t]+\n', '\n', self.code)

        # Join multiline definitions.
        self.code = re.sub('def(.*)\n(.*):', 'def\\1\\2:', self.code)


    def dump(self):

        # Init dump string.
        dumped = ''

        # Write brief license header.
        dumped += ('/* This autogenerated file is under the same license '
            'as the nathive package. */\n\n')

        # Include standard libraries.
        dumped += '#include "Python.h"\n'
        dumped += '#include <stdio.h>\n'

        # Dump functions.
        for function in self.functions:
            dumped += function.dump()

        # Write Python wrapper.
        dumped += 'PyMethodDef methods[] =\n{\n'
        for function in self.functions:
            if function.private: continue
            name = function.name
            dumped += '\t{"%s", %s, METH_VARARGS, ""},\n' % (name, name)
        dumped += '\t{NULL, NULL, 0, NULL}\n};\n'
        dumped += 'PyMODINIT_FUNC init%s(void)\n{\n' % self.name
        dumped += '\t(void) Py_InitModule("%s", methods);\n}' % self.name

        # Return dump string for this script.
        return dumped


    def export(self, path=None):

        ccode = self.dump()
        if path: open(path, 'w').write(ccode)
        else: print ccode
